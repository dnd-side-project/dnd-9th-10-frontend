/* tslint:disable */
/* eslint-disable */
/**
 * BBOK Swagger API
 * DND 9th 10조의 Swagger docs 입니다.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Checklist
 */
export interface Checklist {
    /**
     * 
     * @type {number}
     * @memberof Checklist
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Checklist
     */
    'isChecked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Checklist
     */
    'isGood'?: boolean;
}
/**
 * 
 * @export
 * @interface ChecklistInfoRequest
 */
export interface ChecklistInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof ChecklistInfoRequest
     */
    'criteria'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChecklistInfoRequest
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface CreateBookmarkRequest
 */
export interface CreateBookmarkRequest {
    /**
     * 북마크하는 명언 Id
     * @type {number}
     * @memberof CreateBookmarkRequest
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface CreateDiaryRequest
 */
export interface CreateDiaryRequest {
    /**
     * 체크한 체크리스트 id 배열
     * @type {Array<Checklist>}
     * @memberof CreateDiaryRequest
     */
    'checklist'?: Array<Checklist>;
    /**
     * 일기 내용
     * @type {string}
     * @memberof CreateDiaryRequest
     */
    'content'?: string;
    /**
     * 일기 날짜
     * @type {string}
     * @memberof CreateDiaryRequest
     */
    'date'?: string;
    /**
     * 사용한 이모지
     * @type {string}
     * @memberof CreateDiaryRequest
     */
    'emoji'?: CreateDiaryRequestEmojiEnum;
    /**
     * 사용한 스티커 정보
     * @type {string}
     * @memberof CreateDiaryRequest
     */
    'sticker'?: string;
    /**
     * 태그 목록
     * @type {Array<string>}
     * @memberof CreateDiaryRequest
     */
    'tags'?: Array<string>;
}

export const CreateDiaryRequestEmojiEnum = {
    Angry: 'ANGRY',
    Calm: 'CALM',
    Displeased: 'DISPLEASED',
    Happy: 'HAPPY',
    Panic: 'PANIC',
    Sad: 'SAD'
} as const;

export type CreateDiaryRequestEmojiEnum = typeof CreateDiaryRequestEmojiEnum[keyof typeof CreateDiaryRequestEmojiEnum];

/**
 * 
 * @export
 * @interface CreateDiaryResponse
 */
export interface CreateDiaryResponse {
    /**
     * 친구 적합도
     * @type {number}
     * @memberof CreateDiaryResponse
     */
    'friendPercentage'?: number;
    /**
     * 
     * @type {DiarySaying}
     * @memberof CreateDiaryResponse
     */
    'saying'?: DiarySaying;
}
/**
 * 
 * @export
 * @interface CreateFriendRequest
 */
export interface CreateFriendRequest {
    /**
     * 친구 캐릭터
     * @type {string}
     * @memberof CreateFriendRequest
     */
    'character'?: string;
    /**
     * 친구 이름
     * @type {string}
     * @memberof CreateFriendRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateMemberChecklistRequest
 */
export interface CreateMemberChecklistRequest {
    /**
     * 사용자 정의 기피하는 기준 리스트
     * @type {Array<string>}
     * @memberof CreateMemberChecklistRequest
     */
    'badChecklist'?: Array<string>;
    /**
     * 사용자 정의 이상적인 기준 리스트
     * @type {Array<string>}
     * @memberof CreateMemberChecklistRequest
     */
    'goodChecklist'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DataResponseCreateDiaryResponse
 */
export interface DataResponseCreateDiaryResponse {
    /**
     * 
     * @type {CreateDiaryResponse}
     * @memberof DataResponseCreateDiaryResponse
     */
    'data'?: CreateDiaryResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseCreateDiaryResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseCreateDiaryResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetBasicChecklistResponse
 */
export interface DataResponseGetBasicChecklistResponse {
    /**
     * 
     * @type {GetBasicChecklistResponse}
     * @memberof DataResponseGetBasicChecklistResponse
     */
    'data'?: GetBasicChecklistResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetBasicChecklistResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetBasicChecklistResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetBbokCharacterGroupResponse
 */
export interface DataResponseGetBbokCharacterGroupResponse {
    /**
     * 
     * @type {GetBbokCharacterGroupResponse}
     * @memberof DataResponseGetBbokCharacterGroupResponse
     */
    'data'?: GetBbokCharacterGroupResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetBbokCharacterGroupResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetBbokCharacterGroupResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetBookmarkGroupResponse
 */
export interface DataResponseGetBookmarkGroupResponse {
    /**
     * 
     * @type {GetBookmarkGroupResponse}
     * @memberof DataResponseGetBookmarkGroupResponse
     */
    'data'?: GetBookmarkGroupResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetBookmarkGroupResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetBookmarkGroupResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetDiariesResponse
 */
export interface DataResponseGetDiariesResponse {
    /**
     * 
     * @type {GetDiariesResponse}
     * @memberof DataResponseGetDiariesResponse
     */
    'data'?: GetDiariesResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetDiariesResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetDiariesResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetDiaryResponse
 */
export interface DataResponseGetDiaryResponse {
    /**
     * 
     * @type {GetDiaryResponse}
     * @memberof DataResponseGetDiaryResponse
     */
    'data'?: GetDiaryResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetDiaryResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetDiaryResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetDiaryStickerResponse
 */
export interface DataResponseGetDiaryStickerResponse {
    /**
     * 
     * @type {GetDiaryStickerResponse}
     * @memberof DataResponseGetDiaryStickerResponse
     */
    'data'?: GetDiaryStickerResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetDiaryStickerResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetDiaryStickerResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetFriendGroupResponse
 */
export interface DataResponseGetFriendGroupResponse {
    /**
     * 
     * @type {GetFriendGroupResponse}
     * @memberof DataResponseGetFriendGroupResponse
     */
    'data'?: GetFriendGroupResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetFriendGroupResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetFriendGroupResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetFriendTagsResponse
 */
export interface DataResponseGetFriendTagsResponse {
    /**
     * 
     * @type {GetFriendTagsResponse}
     * @memberof DataResponseGetFriendTagsResponse
     */
    'data'?: GetFriendTagsResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetFriendTagsResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetFriendTagsResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetMemberChecklistResponse
 */
export interface DataResponseGetMemberChecklistResponse {
    /**
     * 
     * @type {GetMemberChecklistResponse}
     * @memberof DataResponseGetMemberChecklistResponse
     */
    'data'?: GetMemberChecklistResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetMemberChecklistResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetMemberChecklistResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DataResponseGetMemberInfoResponse
 */
export interface DataResponseGetMemberInfoResponse {
    /**
     * 
     * @type {GetMemberInfoResponse}
     * @memberof DataResponseGetMemberInfoResponse
     */
    'data'?: GetMemberInfoResponse;
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DataResponseGetMemberInfoResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof DataResponseGetMemberInfoResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface DiaryChecklistResponse
 */
export interface DiaryChecklistResponse {
    /**
     * 
     * @type {string}
     * @memberof DiaryChecklistResponse
     */
    'criteria'?: string;
    /**
     * Member Checklist ID
     * @type {number}
     * @memberof DiaryChecklistResponse
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DiaryChecklistResponse
     */
    'isChecked'?: boolean;
}
/**
 * 
 * @export
 * @interface DiarySaying
 */
export interface DiarySaying {
    /**
     * 명언 내용
     * @type {string}
     * @memberof DiarySaying
     */
    'contents'?: string;
    /**
     * 명언 Id
     * @type {number}
     * @memberof DiarySaying
     */
    'id'?: number;
    /**
     * 북마크 되어있는지 여부
     * @type {boolean}
     * @memberof DiarySaying
     */
    'isMarked'?: boolean;
    /**
     * 명언 출처
     * @type {string}
     * @memberof DiarySaying
     */
    'reference'?: string;
}
/**
 * 
 * @export
 * @interface EditMemberChecklistRequest
 */
export interface EditMemberChecklistRequest {
    /**
     * 
     * @type {Array<ChecklistInfoRequest>}
     * @memberof EditMemberChecklistRequest
     */
    'checklist'?: Array<ChecklistInfoRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof EditMemberChecklistRequest
     */
    'isGood'?: boolean;
}
/**
 * 
 * @export
 * @interface FriendTag
 */
export interface FriendTag {
    /**
     * 
     * @type {number}
     * @memberof FriendTag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FriendTag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetBasicChecklistResponse
 */
export interface GetBasicChecklistResponse {
    /**
     * 기본 기피하는 체크리스트
     * @type {Array<string>}
     * @memberof GetBasicChecklistResponse
     */
    'badChecklist'?: Array<string>;
    /**
     * 기본 이상적인 체크리스트
     * @type {Array<string>}
     * @memberof GetBasicChecklistResponse
     */
    'goodChecklist'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetBbokCharacterGroupResponse
 */
export interface GetBbokCharacterGroupResponse {
    /**
     * 캐릭터 목록
     * @type {Array<GetBbokCharacterResponse>}
     * @memberof GetBbokCharacterGroupResponse
     */
    'characters'?: Array<GetBbokCharacterResponse>;
}
/**
 * 
 * @export
 * @interface GetBbokCharacterResponse
 */
export interface GetBbokCharacterResponse {
    /**
     * 캐릭터 아이콘 Url
     * @type {string}
     * @memberof GetBbokCharacterResponse
     */
    'iconUrl'?: string;
    /**
     * 캐릭터 이름(인장이, 고스미)
     * @type {string}
     * @memberof GetBbokCharacterResponse
     */
    'name'?: string;
    /**
     * 캐릭터 타입(CACTUS, HEDGEHOG)
     * @type {string}
     * @memberof GetBbokCharacterResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GetBookmarkGroupResponse
 */
export interface GetBookmarkGroupResponse {
    /**
     * 북마크한 글귀 리스트
     * @type {Array<GetSayingResponse>}
     * @memberof GetBookmarkGroupResponse
     */
    'bookmarks'?: Array<GetSayingResponse>;
}
/**
 * 
 * @export
 * @interface GetDetailMemberChecklistResponse
 */
export interface GetDetailMemberChecklistResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDetailMemberChecklistResponse
     */
    'criteria'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetDetailMemberChecklistResponse
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface GetDiariesResponse
 */
export interface GetDiariesResponse {
    /**
     * 일화 목록
     * @type {Array<GetDiaryResponse>}
     * @memberof GetDiariesResponse
     */
    'diaries'?: Array<GetDiaryResponse>;
    /**
     * 현재 페이지에 담긴 데이터 개수
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'numberOfElements'?: number;
    /**
     * 시작 offset
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'offset'?: number;
    /**
     * 페이지 당 담을 수 있는 최대 용량의 데이터 개수
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'pageNumber'?: number;
    /**
     * 현재 페이지 번호 (0부터 시작)
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'pageSize'?: number;
    /**
     * 전체 페이지의 개수 (필터링에 만족하는)
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'totalElements'?: number;
    /**
     * 전체 요소 개수 (필터링에 만족하는)
     * @type {number}
     * @memberof GetDiariesResponse
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface GetDiaryResponse
 */
export interface GetDiaryResponse {
    /**
     * 부적합 체크리스트
     * @type {Array<DiaryChecklistResponse>}
     * @memberof GetDiaryResponse
     */
    'badChecklist'?: Array<DiaryChecklistResponse>;
    /**
     * 일기 내용
     * @type {string}
     * @memberof GetDiaryResponse
     */
    'content'?: string;
    /**
     * 일기 작성 날짜
     * @type {string}
     * @memberof GetDiaryResponse
     */
    'date'?: string;
    /**
     * 일기에 사용한 이모지
     * @type {string}
     * @memberof GetDiaryResponse
     */
    'emoji'?: GetDiaryResponseEmojiEnum;
    /**
     * 이모지 다운로드 url
     * @type {string}
     * @memberof GetDiaryResponse
     */
    'emojiUrl'?: string;
    /**
     * 적합 체크리스트
     * @type {Array<DiaryChecklistResponse>}
     * @memberof GetDiaryResponse
     */
    'goodChecklist'?: Array<DiaryChecklistResponse>;
    /**
     * 일기 고유 ID
     * @type {number}
     * @memberof GetDiaryResponse
     */
    'id'?: number;
    /**
     * 스티커 JSON
     * @type {string}
     * @memberof GetDiaryResponse
     */
    'sticker'?: string;
    /**
     * 일기 태그 목록
     * @type {Array<string>}
     * @memberof GetDiaryResponse
     */
    'tags'?: Array<string>;
}

export const GetDiaryResponseEmojiEnum = {
    Angry: 'ANGRY',
    Calm: 'CALM',
    Displeased: 'DISPLEASED',
    Happy: 'HAPPY',
    Panic: 'PANIC',
    Sad: 'SAD'
} as const;

export type GetDiaryResponseEmojiEnum = typeof GetDiaryResponseEmojiEnum[keyof typeof GetDiaryResponseEmojiEnum];

/**
 * 
 * @export
 * @interface GetDiaryStickerResponse
 */
export interface GetDiaryStickerResponse {
    /**
     * 
     * @type {Array<StickerDto>}
     * @memberof GetDiaryStickerResponse
     */
    'stickers'?: Array<StickerDto>;
}
/**
 * 
 * @export
 * @interface GetFriendGroupResponse
 */
export interface GetFriendGroupResponse {
    /**
     * 친구 목록
     * @type {Array<GetFriendResponse>}
     * @memberof GetFriendGroupResponse
     */
    'friends'?: Array<GetFriendResponse>;
}
/**
 * 
 * @export
 * @interface GetFriendResponse
 */
export interface GetFriendResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetFriendResponse
     */
    'active'?: boolean;
    /**
     * 친구 캐릭터 아이콘 url
     * @type {string}
     * @memberof GetFriendResponse
     */
    'characterUrl'?: string;
    /**
     * 친구 관련 일화 수
     * @type {number}
     * @memberof GetFriendResponse
     */
    'countingDiary'?: number;
    /**
     * 친구 고유 ID
     * @type {number}
     * @memberof GetFriendResponse
     */
    'id'?: number;
    /**
     * 친구 이름
     * @type {string}
     * @memberof GetFriendResponse
     */
    'name'?: string;
    /**
     * 친구 점수
     * @type {number}
     * @memberof GetFriendResponse
     */
    'score'?: number;
    /**
     * 친구 생성 날짜
     * @type {string}
     * @memberof GetFriendResponse
     */
    'startedAt'?: string;
}
/**
 * 
 * @export
 * @interface GetFriendTagsResponse
 */
export interface GetFriendTagsResponse {
    /**
     * 태그 목록
     * @type {Array<FriendTag>}
     * @memberof GetFriendTagsResponse
     */
    'tags'?: Array<FriendTag>;
}
/**
 * 
 * @export
 * @interface GetMemberChecklistResponse
 */
export interface GetMemberChecklistResponse {
    /**
     * 이상적인 기준
     * @type {Array<GetDetailMemberChecklistResponse>}
     * @memberof GetMemberChecklistResponse
     */
    'badChecklist'?: Array<GetDetailMemberChecklistResponse>;
    /**
     * 기피하는 기준
     * @type {Array<GetDetailMemberChecklistResponse>}
     * @memberof GetMemberChecklistResponse
     */
    'goodChecklist'?: Array<GetDetailMemberChecklistResponse>;
}
/**
 * 
 * @export
 * @interface GetMemberInfoResponse
 */
export interface GetMemberInfoResponse {
    /**
     * member의 고유 Id
     * @type {string}
     * @memberof GetMemberInfoResponse
     */
    'memberId'?: string;
    /**
     * member의 이름
     * @type {string}
     * @memberof GetMemberInfoResponse
     */
    'memberName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMemberInfoResponse
     */
    'oauth2Provider'?: GetMemberInfoResponseOauth2ProviderEnum;
    /**
     * member의 프로필 이미지 url
     * @type {string}
     * @memberof GetMemberInfoResponse
     */
    'profileUrl'?: string;
}

export const GetMemberInfoResponseOauth2ProviderEnum = {
    Guest: 'GUEST',
    Kakao: 'KAKAO'
} as const;

export type GetMemberInfoResponseOauth2ProviderEnum = typeof GetMemberInfoResponseOauth2ProviderEnum[keyof typeof GetMemberInfoResponseOauth2ProviderEnum];

/**
 * 
 * @export
 * @interface GetSayingResponse
 */
export interface GetSayingResponse {
    /**
     * 명언 내용
     * @type {string}
     * @memberof GetSayingResponse
     */
    'contents'?: string;
    /**
     * 명언 Id
     * @type {number}
     * @memberof GetSayingResponse
     */
    'id'?: number;
    /**
     * 명언 출처
     * @type {string}
     * @memberof GetSayingResponse
     */
    'reference'?: string;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 응답 메시지
     * @type {string}
     * @memberof MessageResponse
     */
    'message'?: string;
    /**
     * 응답 코드
     * @type {number}
     * @memberof MessageResponse
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface StickerDto
 */
export interface StickerDto {
    /**
     * 스티커 이름
     * @type {string}
     * @memberof StickerDto
     */
    'name'?: StickerDtoNameEnum;
    /**
     * 스티커 다운로드 주소
     * @type {string}
     * @memberof StickerDto
     */
    'stickerUrl'?: string;
}

export const StickerDtoNameEnum = {
    Aeng: 'AENG',
    Band: 'BAND',
    Heart: 'HEART',
    Kk: 'KK',
    Poop: 'POOP',
    Rainbow: 'RAINBOW',
    Star: 'STAR',
    Sweetpotato: 'SWEETPOTATO'
} as const;

export type StickerDtoNameEnum = typeof StickerDtoNameEnum[keyof typeof StickerDtoNameEnum];

/**
 * 
 * @export
 * @interface UpdateDiaryRequest
 */
export interface UpdateDiaryRequest {
    /**
     * 체크한 체크리스트 id 배열
     * @type {Array<Checklist>}
     * @memberof UpdateDiaryRequest
     */
    'checklist'?: Array<Checklist>;
    /**
     * 일기 내용
     * @type {string}
     * @memberof UpdateDiaryRequest
     */
    'content'?: string;
    /**
     * 일기 날짜
     * @type {string}
     * @memberof UpdateDiaryRequest
     */
    'date'?: string;
    /**
     * 사용한 이모지
     * @type {string}
     * @memberof UpdateDiaryRequest
     */
    'emoji'?: UpdateDiaryRequestEmojiEnum;
    /**
     * 사용한 스티커 정보
     * @type {string}
     * @memberof UpdateDiaryRequest
     */
    'sticker'?: string;
    /**
     * 태그 목록
     * @type {Array<string>}
     * @memberof UpdateDiaryRequest
     */
    'tags'?: Array<string>;
}

export const UpdateDiaryRequestEmojiEnum = {
    Angry: 'ANGRY',
    Calm: 'CALM',
    Displeased: 'DISPLEASED',
    Happy: 'HAPPY',
    Panic: 'PANIC',
    Sad: 'SAD'
} as const;

export type UpdateDiaryRequestEmojiEnum = typeof UpdateDiaryRequestEmojiEnum[keyof typeof UpdateDiaryRequestEmojiEnum];

/**
 * 
 * @export
 * @interface UpdateFriendRequest
 */
export interface UpdateFriendRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFriendRequest
     */
    'name'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 북마크 추가
         * @param {CreateBookmarkRequest} [createBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkUsingPOST: async (createBookmarkRequest?: CreateBookmarkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookmarkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 정의 체크리스트 추가
         * @param {CreateMemberChecklistRequest} [createMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChecklistUsingPOST: async (createMemberChecklistRequest?: CreateMemberChecklistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/checklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMemberChecklistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 일기 등록
         * @param {number} id 친구 id
         * @param {CreateDiaryRequest} [createDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiaryUsingPOST: async (id: number, createDiaryRequest?: CreateDiaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDiaryUsingPOST', 'id', id)
            const localVarPath = `/api/v1/friend/{id}/diary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 친구 등록
         * @param {CreateFriendRequest} [createFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFriendUsingPOST: async (createFriendRequest?: CreateFriendRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFriendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 친구 관계 정리
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFriendUsingPATCH: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateFriendUsingPATCH', 'id', id)
            const localVarPath = `/api/v1/friend/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 북마크 삭제
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmarkUsingDELETE: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBookmarkUsingDELETE', 'id', id)
            const localVarPath = `/api/v1/bookmark/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 일기 삭제
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiaryUsingDELETE: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiaryUsingDELETE', 'id', id)
            const localVarPath = `/api/v1/friend/diary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 나만의 기준 수정
         * @param {EditMemberChecklistRequest} [editMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChecklistUsingPATCH: async (editMemberChecklistRequest?: EditMemberChecklistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/member/checklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editMemberChecklistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 친구 정보 수정
         * @param {number} id 친구 id
         * @param {UpdateFriendRequest} [updateFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editFriendNameUsingPATCH: async (id: number, updateFriendRequest?: UpdateFriendRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editFriendNameUsingPATCH', 'id', id)
            const localVarPath = `/api/v1/friend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFriendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 기본 체크리스트 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicChecklistUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/checklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 캐릭터 정보 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBbokCharacterUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/character`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 북마크 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarksUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 나만의 기준 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecklistUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/member/checklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 일기 목록 조회
         * @param {number} id 친구 id
         * @param {number} [offset] 목록 오프셋
         * @param {string} [order] 시간 정렬 기준
         * @param {string} [q] 검색어
         * @param {string} [tag] 태그
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiariesUsingGET: async (id: number, offset?: number, order?: string, q?: string, tag?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDiariesUsingGET', 'id', id)
            const localVarPath = `/api/v1/friend/{id}/diary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 일기 상세 조회
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiaryUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDiaryUsingGET', 'id', id)
            const localVarPath = `/api/v1/friend/diary/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 친구 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 마이 페이지에서 사용자의 정보를 볼 수 있습니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 스티커 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickersUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friend/diary/sticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 태그 목록 조회
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTagsUsingGET', 'id', id)
            const localVarPath = `/api/v1/friend/{id}/tag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 일기 수정
         * @param {number} id 일기 id
         * @param {UpdateDiaryRequest} [updateDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiaryUsingPATCH: async (id: number, updateDiaryRequest?: UpdateDiaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDiaryUsingPATCH', 'id', id)
            const localVarPath = `/api/v1/friend/diary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 북마크 추가
         * @param {CreateBookmarkRequest} [createBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmarkUsingPOST(createBookmarkRequest?: CreateBookmarkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmarkUsingPOST(createBookmarkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 정의 체크리스트 추가
         * @param {CreateMemberChecklistRequest} [createMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChecklistUsingPOST(createMemberChecklistRequest?: CreateMemberChecklistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChecklistUsingPOST(createMemberChecklistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 일기 등록
         * @param {number} id 친구 id
         * @param {CreateDiaryRequest} [createDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiaryUsingPOST(id: number, createDiaryRequest?: CreateDiaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseCreateDiaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiaryUsingPOST(id, createDiaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 친구 등록
         * @param {CreateFriendRequest} [createFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFriendUsingPOST(createFriendRequest?: CreateFriendRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFriendUsingPOST(createFriendRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 친구 관계 정리
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateFriendUsingPATCH(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateFriendUsingPATCH(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 북마크 삭제
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBookmarkUsingDELETE(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBookmarkUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 일기 삭제
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiaryUsingDELETE(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiaryUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 나만의 기준 수정
         * @param {EditMemberChecklistRequest} [editMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editChecklistUsingPATCH(editMemberChecklistRequest?: EditMemberChecklistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editChecklistUsingPATCH(editMemberChecklistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 친구 정보 수정
         * @param {number} id 친구 id
         * @param {UpdateFriendRequest} [updateFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editFriendNameUsingPATCH(id: number, updateFriendRequest?: UpdateFriendRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editFriendNameUsingPATCH(id, updateFriendRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 기본 체크리스트 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasicChecklistUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetBasicChecklistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasicChecklistUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 캐릭터 정보 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBbokCharacterUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetBbokCharacterGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBbokCharacterUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 북마크 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarksUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetBookmarkGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarksUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 나만의 기준 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChecklistUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetMemberChecklistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChecklistUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 일기 목록 조회
         * @param {number} id 친구 id
         * @param {number} [offset] 목록 오프셋
         * @param {string} [order] 시간 정렬 기준
         * @param {string} [q] 검색어
         * @param {string} [tag] 태그
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiariesUsingGET(id: number, offset?: number, order?: string, q?: string, tag?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetDiariesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiariesUsingGET(id, offset, order, q, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 일기 상세 조회
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiaryUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetDiaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiaryUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 친구 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriendsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetFriendGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFriendsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 마이 페이지에서 사용자의 정보를 볼 수 있습니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetMemberInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 스티커 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStickersUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetDiaryStickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStickersUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 태그 목록 조회
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponseGetFriendTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagsUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 일기 수정
         * @param {number} id 일기 id
         * @param {UpdateDiaryRequest} [updateDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiaryUsingPATCH(id: number, updateDiaryRequest?: UpdateDiaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiaryUsingPATCH(id, updateDiaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary 북마크 추가
         * @param {CreateBookmarkRequest} [createBookmarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkUsingPOST(createBookmarkRequest?: CreateBookmarkRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.createBookmarkUsingPOST(createBookmarkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 정의 체크리스트 추가
         * @param {CreateMemberChecklistRequest} [createMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChecklistUsingPOST(createMemberChecklistRequest?: CreateMemberChecklistRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.createChecklistUsingPOST(createMemberChecklistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 일기 등록
         * @param {number} id 친구 id
         * @param {CreateDiaryRequest} [createDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiaryUsingPOST(id: number, createDiaryRequest?: CreateDiaryRequest, options?: any): AxiosPromise<DataResponseCreateDiaryResponse> {
            return localVarFp.createDiaryUsingPOST(id, createDiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 친구 등록
         * @param {CreateFriendRequest} [createFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFriendUsingPOST(createFriendRequest?: CreateFriendRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.createFriendUsingPOST(createFriendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 친구 관계 정리
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFriendUsingPATCH(id: number, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.deactivateFriendUsingPATCH(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 북마크 삭제
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmarkUsingDELETE(id: number, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.deleteBookmarkUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 일기 삭제
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiaryUsingDELETE(id: number, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.deleteDiaryUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 나만의 기준 수정
         * @param {EditMemberChecklistRequest} [editMemberChecklistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChecklistUsingPATCH(editMemberChecklistRequest?: EditMemberChecklistRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.editChecklistUsingPATCH(editMemberChecklistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 친구 정보 수정
         * @param {number} id 친구 id
         * @param {UpdateFriendRequest} [updateFriendRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editFriendNameUsingPATCH(id: number, updateFriendRequest?: UpdateFriendRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.editFriendNameUsingPATCH(id, updateFriendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 기본 체크리스트 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicChecklistUsingGET(options?: any): AxiosPromise<DataResponseGetBasicChecklistResponse> {
            return localVarFp.getBasicChecklistUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 캐릭터 정보 제공
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBbokCharacterUsingGET(options?: any): AxiosPromise<DataResponseGetBbokCharacterGroupResponse> {
            return localVarFp.getBbokCharacterUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 북마크 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarksUsingGET(options?: any): AxiosPromise<DataResponseGetBookmarkGroupResponse> {
            return localVarFp.getBookmarksUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 나만의 기준 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecklistUsingGET(options?: any): AxiosPromise<DataResponseGetMemberChecklistResponse> {
            return localVarFp.getChecklistUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 일기 목록 조회
         * @param {number} id 친구 id
         * @param {number} [offset] 목록 오프셋
         * @param {string} [order] 시간 정렬 기준
         * @param {string} [q] 검색어
         * @param {string} [tag] 태그
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiariesUsingGET(id: number, offset?: number, order?: string, q?: string, tag?: string, options?: any): AxiosPromise<DataResponseGetDiariesResponse> {
            return localVarFp.getDiariesUsingGET(id, offset, order, q, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 일기 상세 조회
         * @param {number} id 일기 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiaryUsingGET(id: number, options?: any): AxiosPromise<DataResponseGetDiaryResponse> {
            return localVarFp.getDiaryUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 친구 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendsUsingGET(options?: any): AxiosPromise<DataResponseGetFriendGroupResponse> {
            return localVarFp.getFriendsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 마이 페이지에서 사용자의 정보를 볼 수 있습니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberUsingGET(options?: any): AxiosPromise<DataResponseGetMemberInfoResponse> {
            return localVarFp.getMemberUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 스티커 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickersUsingGET(options?: any): AxiosPromise<DataResponseGetDiaryStickerResponse> {
            return localVarFp.getStickersUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 태그 목록 조회
         * @param {number} id 친구 id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsUsingGET(id: number, options?: any): AxiosPromise<DataResponseGetFriendTagsResponse> {
            return localVarFp.getTagsUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 일기 수정
         * @param {number} id 일기 id
         * @param {UpdateDiaryRequest} [updateDiaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiaryUsingPATCH(id: number, updateDiaryRequest?: UpdateDiaryRequest, options?: any): AxiosPromise<MessageResponse> {
            return localVarFp.updateDiaryUsingPATCH(id, updateDiaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary 북마크 추가
     * @param {CreateBookmarkRequest} [createBookmarkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBookmarkUsingPOST(createBookmarkRequest?: CreateBookmarkRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBookmarkUsingPOST(createBookmarkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 정의 체크리스트 추가
     * @param {CreateMemberChecklistRequest} [createMemberChecklistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createChecklistUsingPOST(createMemberChecklistRequest?: CreateMemberChecklistRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createChecklistUsingPOST(createMemberChecklistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 일기 등록
     * @param {number} id 친구 id
     * @param {CreateDiaryRequest} [createDiaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createDiaryUsingPOST(id: number, createDiaryRequest?: CreateDiaryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createDiaryUsingPOST(id, createDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 친구 등록
     * @param {CreateFriendRequest} [createFriendRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createFriendUsingPOST(createFriendRequest?: CreateFriendRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createFriendUsingPOST(createFriendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 친구 관계 정리
     * @param {number} id 친구 id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deactivateFriendUsingPATCH(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deactivateFriendUsingPATCH(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 북마크 삭제
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteBookmarkUsingDELETE(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteBookmarkUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 일기 삭제
     * @param {number} id 일기 id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteDiaryUsingDELETE(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteDiaryUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 나만의 기준 수정
     * @param {EditMemberChecklistRequest} [editMemberChecklistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editChecklistUsingPATCH(editMemberChecklistRequest?: EditMemberChecklistRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editChecklistUsingPATCH(editMemberChecklistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 친구 정보 수정
     * @param {number} id 친구 id
     * @param {UpdateFriendRequest} [updateFriendRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editFriendNameUsingPATCH(id: number, updateFriendRequest?: UpdateFriendRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editFriendNameUsingPATCH(id, updateFriendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 기본 체크리스트 제공
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBasicChecklistUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBasicChecklistUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 캐릭터 정보 제공
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBbokCharacterUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBbokCharacterUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 북마크 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBookmarksUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBookmarksUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 나만의 기준 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChecklistUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChecklistUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 일기 목록 조회
     * @param {number} id 친구 id
     * @param {number} [offset] 목록 오프셋
     * @param {string} [order] 시간 정렬 기준
     * @param {string} [q] 검색어
     * @param {string} [tag] 태그
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDiariesUsingGET(id: number, offset?: number, order?: string, q?: string, tag?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDiariesUsingGET(id, offset, order, q, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 일기 상세 조회
     * @param {number} id 일기 id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDiaryUsingGET(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDiaryUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 친구 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFriendsUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFriendsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 마이 페이지에서 사용자의 정보를 볼 수 있습니다.
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMemberUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMemberUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 스티커 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStickersUsingGET(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStickersUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 태그 목록 조회
     * @param {number} id 친구 id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTagsUsingGET(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTagsUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 일기 수정
     * @param {number} id 일기 id
     * @param {UpdateDiaryRequest} [updateDiaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateDiaryUsingPATCH(id: number, updateDiaryRequest?: UpdateDiaryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateDiaryUsingPATCH(id, updateDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


